* `git init` - инициализировать гит
* `git add` - добавить файл в гит
  * `git add <список файлов>`
  * `git add .` - добавить все файлы в текущей директории
  * `git add dir/` - добавить все файлы в указанной директории
  * `git add *.java` - добавить все файлы с расширением java  
  * `git add "*.java"` - добавить все файлы В ПРОЕКТЕ с расширением java  
  * `git add dir/*.java` - добавить все файлы в указанной директории с расширением java  
* `git commit -m "Комментарий"` - коммитить файл
  * `git commit -a -m "Комментарий"` = `git add . и git commit -m "Комментарий""` - ОТЛИЧИЕ! Не добавляет в отслеживаемую зону (и в коммит) новые untracked (не отслеживаемые) файлы. Добавляет только модифициарованные (modified) файлы.
  * `git commit --amend -m "Комментарий"` - ДОПОЛНЯЕТ последний коммит добавляя в него свежие изменения. Также изменяет текст сообщения на новое. Новый коммит не создается.
* `git rm` - удалить из гит
* `git status` - статус репозитория
* `git log`- посмотреть логи (историю коммитов)
* `git diff`- показывает разницу между текущим неотслеживаемым состоянием репозитория и последним снимком.
  * `git diff --staged` - показывает разницу между текущим отслеживаемым состоянием репозитория и последним снимком.
  * `git diff {COMMIT_ID}` - показывает разницу между текущим состоянием репозитория и указанным снимком.
* `git reset` - сброс последних изменений `git reset = git reset --mixed HEAD`
  * `git reset HEAD^` - сброс изменений на 1
  * `git reset HEAD^^` - сброс изменений на 2 и т.д.
  * `git reset HEAD~2` - сброс изменений на 2 и т.д.
  * `git reset {COMMIT_ID}` - сброс изменений до указанного хеша
  * `git reset {РЕЖИМ} {COMMIT_ID | HEAD}` - режимы git reset
      * `git reset --soft` - возвращает проект к указанному коммиту, при этом переводит все коммиты после указанного в отслеживаемую (staged) зону
      * `git reset --mixed` - (default) возвращает проект к указанному коммиту, при этом переводит все коммиты после указанного в не отслеживаемую (unstaged) зону
      * `git reset --hard` - удаляет коммиты безвозвратно
* `git checkout` - используется для перемещения между коммитами, версиями отдельных файлов или ветками
  * `git checkout HEAD^` - перемещение к предыдущему коммиту
  * `git checkout HEAD^^` - перемещение на 2 коммита и т.д.
  * `git checkout HEAD~2` - перемещение на 2 коммита и т.д.
  * `git checkout {COMMIT_ID}` - перемещение до указанного хеша
  * `git checkout {COMMIT_ID | HEAD} -- {FILE | FILES}` - возвращает выбранные файлы или файл до указанного коммита 
  * `git checkout -- {FILE | FILES}` - возвращает выбранные файлы или файл к последнему коммиту (HEAD). Работает для не отслеживаемых (untracked | modified) изменений.
  * `git checkout -- .` - возвращает все не отслеживаемые файлы к последнему коммиту (HEAD)
  * `git checkout {BRANCH_NAME}` - переключение на указанную ветку
* `git clean` - удаляет untracked файлы
  * `-d` - рекурсивное удаление
  * `-f --force` - форсированное удаление
  * `-i --interactive` - интерактивное удаление
  * `-n --dry-run` - не удаляет, а лишь показывает, что будет удалено
  * `-e <pattern> --exclude=<pattern>` - исключить
  * `-x` - не использует стандартные правила игнорирования (gitignore), а использует то, что было указано в -e
  * `-X` - удалить только те файлы, которые игнорируются гитом
* `git remote`
  * `-v` - просмотреть список существующий удаленных репозиториев
  * `add {название_репозитория} {адрес_репозитория}` - добавить удаленный репозиторий `git remove add origin https://github.com/***`
  * `remove {название_репозитория}` - удалить удаленный репозиторий
* `git push` - команда для отправки локального репозитория на удаленный
  * `git push {название_удаленного_репозитория} {локальная_ветка}` - например,`git push origin master`
* `git pull` - команда для получения обновлений из удаленного репозитория. Например, `git pull origin master`   `git pull = git fetch & git merge`
* `git clont` - клонировать репозиторий на локальный компьютер
* `git branch` - посмотреть на какой ветке мы находимся
  * `git branch -r` - просмотреть список удаленных веток
  * `git branch {название_ветки}` - создать новую ветку
  * `git branch -d {название_ветки}` - удалить указанную ветку
* `git merge {название_ветки}` - объединяет ветки. Переключаемся на нужную ветку (например, master). Затем используя git merge объединяем указанную ветку с веткой, на которой находимся (например, master).
* `git fetch` - скачивает удаленные ветки с репозитория, но не производит актуализацию локальных веток (слияния удаленной ветки с локальной не происходит)
* `git rebase` - (перебазирование) похожа на git merge, но в отличие от merge, команда rebase при слиянии (не! fast-forward) не создает merge commit. Нужен для манипуляций с ветками. Берет коммиты из другой ветки, перемещает в текущую ветку и поверх этих коммитов по одному применяет коммиты из временной зоны.
  * `git rebase --abort`
  * `git rebase --continue`
  * `git rebase --skip`
* `git rebase -i` - интерактивный rebase. В отличие от git rebase он работает на одной ветке. Он берет коммиты из текущей ветки и помещает некоторые коммиты во временную зону. Затем применяет эти коммиты к текущей ветке (в момент применения мы можем изменить коммиты). Можно например, объединять коммиты (squash) и т.д.
  * `pick`
  * `reword`
  * `edit`
  * `squash`
  * `fixup`
  * `exec`
  * `drop`
* `git cherry-pick {COMMIT_HASH}` - можно по хешу выбрать коммит и добавить данный коммит в ту ветку, в которой находимся.
  * `git cherry-pick --edit {COMMIT_HASH}` - позволяет в процессе переноса изменить сообщение коммита
  * `git cherry-pick --no-commit {COMMIT_HASH}` - позволяет перенести выбранный коммит в ветку, но при этом не создается коммит. Изменения находятся в отслеживаемой зоне
  * `git cherry-pick -x {COMMIT_HASH}` - при cherry-pick в сообщении коммита будет указан хэш коммита, из которого был сделан cherry-pick
  * `git cherry-pick --signoff {COMMIT_HASH}` - указывает в сообщении имя пользователя, кто сделал cherry-pick
  
> После создания файлы приобретают статус -> untracked (не отслеживаемый)

> При редактировании файла статус -> modified (измененный)

> После добавления файла статус файла -> staged (подготовленный)

> После коммита файла статус файла -> committed (зафиксированный)
 
> При использовании git checkout указатель HEAD находится в состоянии DETACHED. Он отделен от актуальной версии проекта. Любые изменения или коммиты сделанные в этом состоянии удаляются сборщиком мусора при переходе к другому коммиту.

